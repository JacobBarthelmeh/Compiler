<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>Parser</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice 4.1.1  (Unix)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="jak TheOne">
	<META NAME="CHANGED" CONTENT="20150506;20110500">
	<!-- InstanceBegin template="/Templates/page.dwt" codeOutsideHTMLIsLocked="false" -->
	<SCRIPT SRC="../../../../Scripts/google-code-prettify/run_prettify.js"></SCRIPT>
	<SCRIPT SRC="../../../../Scripts/recomputeAttributes.js"></SCRIPT>
	<!-- InstanceBeginEditable name="doctitle" -->
	<!-- InstanceEndEditable -->
	<!-- <div id="browser-window-veil">
</div>
-->
	<STYLE TYPE="text/css">
	<!--
		H2.ctl { font-family: "Arial Unicode MS" }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<DIV ID="page-container" DIR="LTR">
	<P><BR><BR>
	</P>
	<DIV ID="track-icon1" DIR="LTR">
		<P><IMG SRC="../../../../Media/StyleImages/bobcat-small.png" NAME="graphics1" ALIGN=BOTTOM WIDTH=75 HEIGHT=48 BORDER=0></P>
	</DIV>
	<DIV ID="track-icon2" DIR="LTR">
		<P><BR><BR>
		</P>
	</DIV>
	<DIV ID="track-icon3" DIR="LTR">
		<P><BR><BR>
		</P>
	</DIV>
	<DIV ID="headMatter" DIR="LTR">
		<P><A NAME="headTitle1"></A><A NAME="headTitle2"></A><!-- InstanceBeginEditable name="Header" -->Team
		4<!-- InstanceEndEditable --> 
		</P>
	</DIV>
	<DIV ID="asideLeftTitle" DIR="LTR">
		<P>Compilers 2015 
		</P>
	</DIV>
	<DIV ID="footMatter" DIR="LTR">
		<P><A NAME="previousPageLink"></A><A NAME="currentPageNumber"></A><A NAME="nextPageLink"></A>
		<BR><BR>
		</P>
	</DIV>
	<H1><!-- InstanceBeginEditable name="Main" -->Parser</H1>
	<H2 CLASS="western">Specifications</H2>
	<P>Click <A HREF="../../../01_Introduction/2_Project_Specifications/2_Parser_Specifications.html">here</A>
	to view the parser specifications. 
	</P>
	<H2 CLASS="western">Source Listing</H2>
	<PRE>
<CODE>package parser;</CODE>

<CODE>import compiler.Compiler;</CODE>
<CODE>import compiler.Token;</CODE>
<CODE>import symboltable.Parameter;</CODE>
<CODE>import symboltable.SymbolTableHandler;</CODE>
<CODE>import java.io.PrintWriter;</CODE>
<CODE>import java.util.ArrayList;</CODE>
<CODE>import java.util.Arrays;</CODE>
<CODE>import scanner.Scanner;</CODE>
<CODE>import semanticanalyzer.SemanticAnalyzer;</CODE>
<CODE>import semanticanalyzer.SemanticRecord;</CODE>
<CODE>import symboltable.Symbol;</CODE>
<CODE>import util.*;</CODE>

<CODE>public class Parser {</CODE>

<CODE>    // ll(1) table rules</CODE>
<CODE>    // See Complete-LL(1)-Table-2015-03-10.xlsx for information</CODE>
<CODE>    // Nonterminal 1</CODE>
<CODE>    // &lt;SystemGoal&gt; --&gt; &lt;Program&gt; EOF RULE #1</CODE>
<CODE>    private void SystemGoal() {</CODE>
<CODE>        stackTrace += &quot;SystemGoal\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.SystemGoal)) {</CODE>
<CODE>            case 1:</CODE>
<CODE>                Program(); // nonterminal 2</CODE>
<CODE>                if (l1.getTerminal() == Terminal.EOF) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    //  Closes the file to complete genWrite_S</CODE>
<CODE>                    sa.genHalt();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;end of file&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;program&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 2</CODE>
<CODE>    // &lt;Program&gt; --&gt; &lt;ProgramHeading&gt; ; &lt;Block&gt; . RULE #2</CODE>
<CODE>    private void Program() {</CODE>
<CODE>        stackTrace += &quot;Program\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.Program)) {</CODE>
<CODE>            case 2:</CODE>
<CODE>                sh.pushTable(); //  Construct the original table</CODE>
<CODE>                int nestingL = sh.nestinglevel;</CODE>
<CODE>                //push registers on stack so that they can be restored after run</CODE>
<CODE>                sa.genStoreRegisters(nestingL);</CODE>
<CODE>                ProgramHeading(); // nonterminal 3</CODE>
<CODE>                if (l1.getTerminal() == Terminal.SCOLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;;&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                Block(); // nonterminal 4</CODE>
<CODE>                if (l1.getTerminal() == Terminal.PERIOD) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;.&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                //restore the register values</CODE>
<CODE>                sa.genRestoreRegisters(nestingL);</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;program&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 3</CODE>
<CODE>    // &lt;ProgramHeading&gt; --&gt; program &lt;ProgramIdentifier&gt; RULE #3</CODE>
<CODE>    private void ProgramHeading() {</CODE>
<CODE>        stackTrace += &quot;ProgramHeading\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ProgramHeading)) {</CODE>
<CODE>            case 3:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.PROGRAM) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;program&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                ProgramIdentifier();</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;program&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 4</CODE>
<CODE>    // &lt;Block&gt; --&gt; &lt;VariableDeclarationPart&gt; &lt;ProcedureAndFunctionDeclarationPart&gt; &lt;StatementPart&gt; RULE #4</CODE>
<CODE>    private void Block() {</CODE>
<CODE>        stackTrace += &quot;Block\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.Block)) {</CODE>
<CODE>            case 4:</CODE>
<CODE>                ArrayList&lt;Symbol&gt; locals = new ArrayList&lt;&gt;();</CODE>
<CODE>                VariableDeclarationPart(locals);</CODE>
<CODE>                ProcedureAndFunctionDeclarationPart();</CODE>
<CODE>                StatementPart();</CODE>
<CODE>                sa.removeLocals(locals);</CODE>
<CODE>                sh.popTable();</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;var&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 5</CODE>
<CODE>    // &lt;VariableDeclarationPart&gt; --&gt; &lt;VariableDeclaration&gt; ; &lt;VariableDeclarationTail&gt; RULE #5</CODE>
<CODE>    // &lt;VariableDeclarationPart&gt; --&gt; lambda RULE #6</CODE>
<CODE>    private void VariableDeclarationPart(ArrayList&lt;Symbol&gt; locals) {</CODE>
<CODE>        stackTrace += &quot;VariableDeclarationPart\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.VariableDeclarationPart)) {</CODE>
<CODE>            case 5:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.VAR) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;var&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                VariableDeclaration(locals);</CODE>
<CODE>                if (l1.getTerminal() == Terminal.SCOLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;;&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                VariableDeclarationTail(locals);</CODE>
<CODE>                break;</CODE>
<CODE>            case 6:</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;var&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 6</CODE>
<CODE>    // &lt;VariableDeclarationTail&gt; --&gt; &lt;VariableDeclaration&gt; ; &lt;VariableDeclarationTail&gt; RULE #7</CODE>
<CODE>    // &lt;VariableDeclarationTail&gt; --&gt; lambda RULE #8</CODE>
<CODE>    private void VariableDeclarationTail(ArrayList&lt;Symbol&gt; locals) {</CODE>
<CODE>        stackTrace += &quot;VariableDeclarationTail\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.VariableDeclarationTail)) {</CODE>
<CODE>            case 7:</CODE>
<CODE>                VariableDeclaration(locals);</CODE>
<CODE>                if (l1.getTerminal() == Terminal.SCOLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;;&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                VariableDeclarationTail(locals);</CODE>
<CODE>                break;</CODE>
<CODE>            case 8:</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;Integer&quot;, &quot;Float&quot;, &quot;String&quot;, &quot;Boolean&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 7</CODE>
<CODE>    // VariableDeclaration&gt; --&gt; &lt;IdentifierList&gt; : &lt;Type&gt; RULE #9</CODE>
<CODE>    private void VariableDeclaration(ArrayList&lt;Symbol&gt; locals) {</CODE>
<CODE>        stackTrace += &quot;VariableDeclaration\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.VariableDeclaration)) {</CODE>
<CODE>            case 9:</CODE>
<CODE>                ArrayList&lt;String&gt; str = IdentifierList();</CODE>
<CODE>                if (l1.getTerminal() == Terminal.COLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;:&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                Type type = Type();</CODE>
<CODE>                for (String s : str) {</CODE>
<CODE>                    sh.startEntry();</CODE>
<CODE>                    sh.setName(s);</CODE>
<CODE>                    sh.setType(type);</CODE>
<CODE>                    sh.setKind(Kind.VARIABLE);</CODE>
<CODE>                    sh.finishEntry();</CODE>
<CODE>                    locals.add(sh.getEntry(s));</CODE>
<CODE>                    sa.padForVariable();</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;identifier&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 8</CODE>
<CODE>    // &lt;Type&gt; --&gt; Integer RULE #10</CODE>
<CODE>    // &lt;Type&gt; --&gt; Float RULE #11</CODE>
<CODE>    // &lt;Type&gt; --&gt; String RULE #12</CODE>
<CODE>    // &lt;Type&gt; --&gt; Boolean RULE #13</CODE>
<CODE>    private Type Type() {</CODE>
<CODE>        stackTrace += &quot;Type\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.Type)) {</CODE>
<CODE>            case 10:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.INTEGER) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    return Type.INTEGER;</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;Integer&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                    return Type.NOTYPE;</CODE>
<CODE>                }</CODE>
<CODE>            case 11:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.FLOAT) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    return Type.FLOAT;</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;Float&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                    return Type.NOTYPE;</CODE>
<CODE>                }</CODE>
<CODE>            case 12:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.STRING) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    return Type.STRING;</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;String&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                    return Type.NOTYPE;</CODE>
<CODE>                }</CODE>
<CODE>            case 13:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.BOOLEAN) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    return Type.BOOLEAN;</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;Boolean&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                    return Type.NOTYPE;</CODE>
<CODE>                }</CODE>
<CODE>            default:</CODE>
<CODE>                String err[] = {&quot;Integer&quot;, &quot;Float&quot;, &quot;String&quot;, &quot;Boolean&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                return Type.NOTYPE;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 9</CODE>
<CODE>    // &lt;ProcedureAndFunctionDeclarationPart&gt; --&gt; &lt;ProcedureDeclaration&gt; &lt;ProcedureAndFunctionDeclarationPart&gt; RULE #14</CODE>
<CODE>    // &lt;ProcedureAndFunctionDeclarationPart&gt; --&gt; &lt;FunctionDeclaration&gt; &lt;ProcedureAndFunctionDeclarationPart&gt; RULE #15</CODE>
<CODE>    // &lt;ProcedureAndFunctionDeclarationPart&gt; --&gt; lambda RULE #16</CODE>
<CODE>    private void ProcedureAndFunctionDeclarationPart() {</CODE>
<CODE>        stackTrace += &quot;ProcedureAndFunctionDeclarationPart\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ProcedureAndFunctionDeclarationPart)) {</CODE>
<CODE>            case 14:</CODE>
<CODE>                int label = sa.newLabel();</CODE>
<CODE>                //  Jump over the procedures and declarations... for now</CODE>
<CODE>                sa.genBranch(label);</CODE>
<CODE>                ProcedureDeclaration();</CODE>
<CODE>                ProcedureAndFunctionDeclarationPart();</CODE>
<CODE>                //  Go right to the statements</CODE>
<CODE>                sa.putLabel(label);</CODE>
<CODE>                break;</CODE>
<CODE>            case 15:</CODE>
<CODE>                label = sa.newLabel();</CODE>
<CODE>                //  Jump over the procedures and declarations... for now</CODE>
<CODE>                sa.genBranch(label);</CODE>
<CODE>                FunctionDeclaration();</CODE>
<CODE>                ProcedureAndFunctionDeclarationPart();</CODE>
<CODE>                //  Go right to the statements</CODE>
<CODE>                sa.putLabel(label);</CODE>
<CODE>                break;</CODE>
<CODE>            case 16:</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String err[] = {&quot;procedure&quot;, &quot;function&quot;, &quot;begin&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 10</CODE>
<CODE>    // &lt;ProcedureDeclaration --&gt; &lt;ProcedureHeading&gt; ; &lt;Block&gt; ; RULE #17</CODE>
<CODE>    private void ProcedureDeclaration() {</CODE>
<CODE>        stackTrace += &quot;ProcedureDeclaration\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ProcedureDeclaration)) {</CODE>
<CODE>            case 17:</CODE>
<CODE>                Symbol entry = ProcedureHeading();</CODE>
<CODE>                if (l1.getTerminal() == Terminal.SCOLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;;&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                Block();</CODE>
<CODE>                sa.onEndFormalCall(entry);</CODE>
<CODE>                if (l1.getTerminal() == Terminal.SCOLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;;&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;;&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 11</CODE>
<CODE>    // &lt;FunctionDeclaration&gt; --&gt; &lt;FunctionHeading&gt; ; &lt;Block&gt; ; RULE #18</CODE>
<CODE>    private void FunctionDeclaration() {</CODE>
<CODE>        stackTrace += &quot;FunctionDeclaration\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.FunctionDeclaration)) {</CODE>
<CODE>            case 18:</CODE>
<CODE>                Symbol entry = FunctionHeading();</CODE>
<CODE>                if (l1.getTerminal() == Terminal.SCOLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;;&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                Block();</CODE>
<CODE>                sa.onEndFormalCall(entry);</CODE>
<CODE>                if (l1.getTerminal() == Terminal.SCOLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;;&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;;&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 12</CODE>
<CODE>    // &lt;ProcedureHeading&gt; --&gt; procedure &lt;ProcedureIdentifier&gt; &lt;OptionalFormalParameterList&gt; RULE #19</CODE>
<CODE>    private Symbol ProcedureHeading() {</CODE>
<CODE>        stackTrace += &quot;ProcedureHeading\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ProcedureHeading)) {</CODE>
<CODE>            case 19:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.PROCEDURE) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;procedure&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                String name = ProcedureIdentifier();</CODE>
<CODE>                sh.startEntry();</CODE>
<CODE>                sh.setName(name);</CODE>
<CODE>                sh.setType(Type.NOTYPE);</CODE>
<CODE>                sh.setKind(Kind.PROCEDURE);</CODE>
<CODE>                OptionalFormalParameterList();  //  &lt;-- Parser component</CODE>
<CODE>                sh.finishEntry();</CODE>
<CODE>                Symbol entry = sh.getEntry(name);</CODE>
<CODE>                ArrayList&lt;Parameter&gt; params = sh.getEntry(name).params;</CODE>
<CODE>                sh.pushTable();</CODE>
<CODE>                for (Parameter p : params) {</CODE>
<CODE>                    sh.startEntry();</CODE>
<CODE>                    sh.setName(p.name);</CODE>
<CODE>                    sh.setType(p.type);</CODE>
<CODE>                    if (p.kind == Kind.INPARAMETER) {</CODE>
<CODE>                        sh.setKind(Kind.INVARIABLE);</CODE>
<CODE>                    } else {</CODE>
<CODE>                        sh.setKind(Kind.INOUTVARIABLE);</CODE>
<CODE>                    }</CODE>
<CODE>                    sh.finishEntry();</CODE>
<CODE>                }</CODE>
<CODE>                sa.onStartFormalCall(entry);</CODE>
<CODE>                return entry;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;procedure&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 13</CODE>
<CODE>    // &lt;FunctionHeading&gt; --&gt; function &lt;FunctionIdentifier&gt; &lt;OptionalFormalParameterList&gt; : &lt;Type&gt; RULE #20</CODE>
<CODE>    private Symbol FunctionHeading() {</CODE>
<CODE>        stackTrace += &quot;FunctionHeading\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.FunctionHeading)) {</CODE>
<CODE>            case 20:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.FUNCTION) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;function&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                String name = FunctionIdentifier();</CODE>
<CODE>                sh.startEntry();</CODE>
<CODE>                sh.setName(name);</CODE>
<CODE>                sh.setKind(Kind.FUNCTION);</CODE>
<CODE>                OptionalFormalParameterList();  //  &lt;-- Parser component</CODE>
<CODE>                sh.finishEntry();</CODE>
<CODE>                Symbol entry = sh.getEntry(name);</CODE>
<CODE>                ArrayList&lt;Parameter&gt; params = entry.params;</CODE>
<CODE>                sh.pushTable();</CODE>
<CODE>                //create a spot for return value in the symbol table</CODE>
<CODE>                sh.startEntry();</CODE>
<CODE>                sh.setName(&quot;1&quot;); //no identifiers can start with an int so is unique</CODE>
<CODE>                sh.setType(Type.RETURN);</CODE>
<CODE>                sh.setKind(Kind.NOKIND);</CODE>
<CODE>                sh.finishEntry();</CODE>
<CODE>                for (Parameter p : params) {</CODE>
<CODE>                    sh.startEntry();</CODE>
<CODE>                    sh.setName(p.name);</CODE>
<CODE>                    sh.setType(p.type);</CODE>
<CODE>                    if (p.kind == Kind.INPARAMETER) {</CODE>
<CODE>                        sh.setKind(Kind.INVARIABLE);</CODE>
<CODE>                    } else {</CODE>
<CODE>                        sh.setKind(Kind.INOUTVARIABLE);</CODE>
<CODE>                    }</CODE>
<CODE>                    sh.finishEntry();</CODE>
<CODE>                }</CODE>
<CODE>                sa.onStartFormalCall(entry);</CODE>
<CODE>                if (l1.getTerminal() == Terminal.COLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;:&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                Type t = Type();</CODE>
<CODE>                entry.type = t;</CODE>
<CODE>                return entry;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;function&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 14</CODE>
<CODE>    // &lt;OptionalFormalParameterList&gt; --&gt; ( &lt;FormalParameterSection&gt; &lt;FormalParameterSectionTail&gt; ) RULE #21</CODE>
<CODE>    // &lt;OptionalFormalParameterList&gt; --&gt; lambda RULE #22</CODE>
<CODE>    private void OptionalFormalParameterList() {</CODE>
<CODE>        stackTrace += &quot;OptionalFormalParameterList\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.OptionalFormalParameterList)) {</CODE>
<CODE>            case 21:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.LPAREN) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;(&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                FormalParameterSection();</CODE>
<CODE>                FormalParameterSectionTail();</CODE>
<CODE>                if (l1.getTerminal() == Terminal.RPAREN) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;)&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            case 22:</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;(&quot;, &quot;:&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 15</CODE>
<CODE>    // &lt;FormalParameterSectionTail&gt; --&gt; ; &lt;FormalParameterSection&gt; &lt;FormalParameterSectionTail&gt; RULE #23</CODE>
<CODE>    // &lt;FormalParameterSectionTail&gt; --&gt; lambda RULE #24</CODE>
<CODE>    private void FormalParameterSectionTail() {</CODE>
<CODE>        stackTrace += &quot;FormalParameterSectionTail\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.FormalParameterSectionTail)) {</CODE>
<CODE>            case 23:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.SCOLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;;&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                FormalParameterSection();</CODE>
<CODE>                FormalParameterSectionTail();</CODE>
<CODE>                break;</CODE>
<CODE>            case 24:</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;;&quot;, &quot;)&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 16</CODE>
<CODE>    // &lt;FormalParamaterSection&gt; --&gt; &lt;ValueParameterSection&gt; RULE #25</CODE>
<CODE>    // &lt;FormalParamaterSection&gt; --&gt; &lt;VariableParameterSection&gt; RULE #26</CODE>
<CODE>    private void FormalParameterSection() {</CODE>
<CODE>        stackTrace += &quot;FormalParameterSection\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.FormalParameterSection)) {</CODE>
<CODE>            case 25:</CODE>
<CODE>                ValueParameterSection();</CODE>
<CODE>                break;</CODE>
<CODE>            case 26:</CODE>
<CODE>                VariableParameterSection();</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;identifier&quot;, &quot;var&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 17</CODE>
<CODE>    // &lt;ValueParameterSection&gt; --&gt; &lt;IdentifierList&gt; : &lt;Type&gt; RULE #27</CODE>
<CODE>    private void ValueParameterSection() {</CODE>
<CODE>        stackTrace += &quot;ValueParameterSection\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ValueParameterSection)) {</CODE>
<CODE>            case 27:</CODE>
<CODE>                ArrayList&lt;String&gt; str = IdentifierList();</CODE>
<CODE>                if (l1.getTerminal() == Terminal.COLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;:&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                Type type = Type();</CODE>
<CODE>                for (String s : str) {</CODE>
<CODE>                    sh.startParameter();</CODE>
<CODE>                    sh.setName(s);</CODE>
<CODE>                    sh.setType(type);</CODE>
<CODE>                    sh.setKind(Kind.INPARAMETER);</CODE>
<CODE>                    sh.finishParameter();</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;:&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 18</CODE>
<CODE>    // &lt;VariableParameterSection&gt; --&gt; var &lt;IdentifierList&gt; : &lt;Type&gt; RULE #28</CODE>
<CODE>    private void VariableParameterSection() {</CODE>
<CODE>        stackTrace += &quot;VariableParameterSection\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.VariableParameterSection)) {</CODE>
<CODE>            case 28:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.VAR) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;var&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                ArrayList&lt;String&gt; str = IdentifierList();</CODE>
<CODE>                if (l1.getTerminal() == Terminal.COLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;:&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                Type type = Type();</CODE>
<CODE>                for (String s : str) {</CODE>
<CODE>                    sh.startParameter();</CODE>
<CODE>                    sh.setName(s);</CODE>
<CODE>                    sh.setType(type);</CODE>
<CODE>                    sh.setKind(Kind.INOUTPARAMETER);</CODE>
<CODE>                    sh.finishParameter();</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;var&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 19</CODE>
<CODE>    // &lt;StatementPart&gt; --&gt; &lt;CompoundStatement&gt; RULE #29</CODE>
<CODE>    private void StatementPart() {</CODE>
<CODE>        stackTrace += &quot;StatementPart\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.StatementPart)) {</CODE>
<CODE>            case 29:</CODE>
<CODE>                CompoundStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;begin&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 20</CODE>
<CODE>    // &lt;CompoundStatement&gt; --&gt; begin &lt;StatementSequence&gt; end RULE #30</CODE>
<CODE>    private void CompoundStatement() {</CODE>
<CODE>        stackTrace += &quot;CompoundStatement\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.CompoundStatement)) {</CODE>
<CODE>            case 30:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.BEGIN) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;begin&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                StatementSequence();</CODE>
<CODE>                if (l1.getTerminal() == Terminal.END) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;end&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;begin&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 21</CODE>
<CODE>    // &lt;StatementSequence&gt; --&gt; &lt;Statement&gt; &lt;StatementTail&gt; RULE #31</CODE>
<CODE>    private void StatementSequence() {</CODE>
<CODE>        stackTrace += &quot;StatementSequence\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.StatementSequence)) {</CODE>
<CODE>            case 31:</CODE>
<CODE>                Statement();</CODE>
<CODE>                StatementTail();</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;begin&quot;, &quot;read&quot;, &quot;write&quot;, &quot;writeln&quot;, &quot;if&quot;,</CODE>
<CODE>                    &quot;repeat&quot;, &quot;for&quot;, &quot;procedure&quot;, &quot;identifier&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 22</CODE>
<CODE>    // &lt;StatementTail --&gt; ; &lt;statement&gt; &lt;StatementTail&gt; RULE #32</CODE>
<CODE>    // &lt;StatementTail --&gt; lambda RULE #33</CODE>
<CODE>    private void StatementTail() {</CODE>
<CODE>        stackTrace += &quot;StatementTail\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.StatementTail)) {</CODE>
<CODE>            case 32:</CODE>
<CODE>                if (l1.getTerminal() == Terminal.SCOLON) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;;&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                Statement();</CODE>
<CODE>                StatementTail();</CODE>
<CODE>                break;</CODE>
<CODE>            case 33:</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;;&quot;, &quot;end&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 23</CODE>
<CODE>    // Statement --&gt; &lt;EmptyStatement&gt; RULE #34</CODE>
<CODE>    // Statement --&gt; &lt;CompoundStatement&gt; RULE #35</CODE>
<CODE>    // Statement --&gt; &lt;ReadStatement&gt; RULE #36</CODE>
<CODE>    // Statement --&gt; &lt;WriteStatement&gt; RULE #37</CODE>
<CODE>    // Statement --&gt; &lt;AssignmentStatement&gt; RULE #38</CODE>
<CODE>    // Statement --&gt; &lt;IfStatement&gt; RULE #39</CODE>
<CODE>    // Statement --&gt; &lt;WhileStatement&gt; RULE #40</CODE>
<CODE>    // Statement --&gt; &lt;RepeatStatement&gt; RULE #41</CODE>
<CODE>    // Statement --&gt; &lt;ForStatement&gt; RULE #42</CODE>
<CODE>    // Statement --&gt; &lt;ProcedureStatement&gt; RULE #43</CODE>
<CODE>    private void Statement() {</CODE>
<CODE>        stackTrace += &quot;Statement\n&quot;;</CODE>
<CODE>        int rule = getRule(NonTerminal.Statement);</CODE>
<CODE>        if (rule == 38) {</CODE>
<CODE>            l2 = scanner.nextToken();</CODE>
<CODE>            if (l2.getTerminal() != Terminal.ASSIGN) {</CODE>
<CODE>                rule = 43;</CODE>
<CODE>            }</CODE>
<CODE>        }</CODE>
<CODE>        switch (rule) {</CODE>
<CODE>            case 34:</CODE>
<CODE>                EmptyStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            case 35:</CODE>
<CODE>                CompoundStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            case 36:</CODE>
<CODE>                ReadStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            case 37:</CODE>
<CODE>                WriteStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            case 38:</CODE>
<CODE>                AssignmentStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            case 39:</CODE>
<CODE>                IfStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            case 40:</CODE>
<CODE>                WhileStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            case 41:</CODE>
<CODE>                RepeatStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            case 42:</CODE>
<CODE>                ForStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            case 43:</CODE>
<CODE>                ProcedureStatement();</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;begin&quot;, &quot;read&quot;, &quot;write&quot;, &quot;writeln&quot;, &quot;if&quot;,</CODE>
<CODE>                    &quot;repeat&quot;, &quot;for&quot;, &quot;procedure&quot;, &quot;identifier&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    //**************************************************************************</CODE>
<CODE>    // rules 40-47 </CODE>
<CODE>    // Jacob Barthelmeh</CODE>
<CODE>    // Nonterminal 24</CODE>
<CODE>    // &lt;EmptyStatement&gt; --&gt; lambda RULE #44</CODE>
<CODE>    private void EmptyStatement() {</CODE>
<CODE>        stackTrace += &quot;EmptyStatement\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.EmptyStatement)) {</CODE>
<CODE>            case 44:</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 25</CODE>
<CODE>    // &lt;ReadStatement&gt; --&gt; genRead ( &lt;ReadParameter&gt; &lt;ReadParameterTail&gt; ) // 45</CODE>
<CODE>    private void ReadStatement() {</CODE>
<CODE>        stackTrace += &quot;ReadStatement\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ReadStatement)) {</CODE>
<CODE>            case 45://rule 45</CODE>
<CODE>                if (l1.getTerminal() == Terminal.READ) { //rule 45</CODE>
<CODE>                    match();</CODE>
<CODE>                    if (l1.getTerminal() == Terminal.LPAREN) {</CODE>
<CODE>                        match();</CODE>
<CODE>                        ReadParameter();</CODE>
<CODE>                        ReadParameterTail();</CODE>
<CODE>                        if (l1.getTerminal() == Terminal.RPAREN) {</CODE>
<CODE>                            match();</CODE>
<CODE>                        } else {</CODE>
<CODE>                            String[] err = {&quot;)&quot;};</CODE>
<CODE>                            error(err);</CODE>
<CODE>                        }</CODE>
<CODE>                    } else {</CODE>
<CODE>                        String[] err = {&quot;(&quot;};</CODE>
<CODE>                        error(err);</CODE>
<CODE>                    }</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;read&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>

<CODE>    }</CODE>

<CODE>    // Nonterminal 26</CODE>
<CODE>    // &lt;ReadParameterTail --&gt; , &lt;ReadParameter&gt; &lt;ReadParameterTail&gt; RULE #46</CODE>
<CODE>    // &lt;ReadParameterTail --&gt; lambda RULE #47</CODE>
<CODE>    private void ReadParameterTail() {</CODE>
<CODE>        stackTrace += &quot;ReadParameterTail\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ReadParameterTail)) {</CODE>
<CODE>            case 46: //rule 46</CODE>
<CODE>                match();</CODE>
<CODE>                ReadParameter();</CODE>
<CODE>                ReadParameterTail();</CODE>
<CODE>                break;</CODE>
<CODE>            case 47://handle case of e rule 47</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;comma&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 27</CODE>
<CODE>    // &lt;ReadParameter&gt; --&gt; &lt;VariableIdentifier&gt; RULE #48</CODE>
<CODE>    private void ReadParameter() {</CODE>
<CODE>        stackTrace += &quot;ReadParameter\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ReadParameter)) {</CODE>
<CODE>            case 48://rule 48</CODE>
<CODE>                Token t = l1;</CODE>
<CODE>                VariableIdentifier();</CODE>
<CODE>                sa.genRead(new SemanticRecord(t, sh.getEntry(t.getContents())));</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 28</CODE>
<CODE>// &lt;WriteStatement&gt; --&gt; write  ( &lt;WriteParameter&gt; &lt;WriteParameterTail&gt; //49</CODE>
<CODE>// &lt;WriteStatement&gt; --&gt; writeln ( &lt;WriteParameter&gt; &lt;WriteParameterTail&gt; ) //  50</CODE>
<CODE>    private void WriteStatement() {</CODE>
<CODE>        stackTrace += &quot;WriteStatment\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.WriteStatement)) {</CODE>
<CODE>            case 49: //rule 49</CODE>
<CODE>                match();</CODE>
<CODE>                if (l1.getTerminal() == Terminal.LPAREN) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    sa.startWrite();</CODE>
<CODE>                    WriteParameter();</CODE>
<CODE>                    WriteParameterTail();</CODE>
<CODE>                    sa.finishWrite(false);</CODE>
<CODE>                    if (l1.getTerminal() == Terminal.RPAREN) {</CODE>
<CODE>                        match();</CODE>
<CODE>                    } else {</CODE>
<CODE>                        String[] err = {&quot;)&quot;};</CODE>
<CODE>                        error(err);</CODE>
<CODE>                    }</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;(&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>

<CODE>            case 50: //rule 50</CODE>
<CODE>                match();</CODE>
<CODE>                if (l1.getTerminal() == Terminal.LPAREN) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    sa.startWrite();</CODE>
<CODE>                    WriteParameter();</CODE>
<CODE>                    WriteParameterTail();</CODE>
<CODE>                    sa.finishWrite(true);</CODE>
<CODE>                    if (l1.getTerminal() == Terminal.RPAREN) {</CODE>
<CODE>                        match();</CODE>
<CODE>                    } else {</CODE>
<CODE>                        String[] err = {&quot;)&quot;};</CODE>
<CODE>                        error(err);</CODE>
<CODE>                    }</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;(&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>

<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;write&quot;, &quot;writeln&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 29</CODE>
<CODE>    // &lt;WriteParameterTail&gt; --&gt; , &lt;WriteParameter&gt; &lt;WrieteParameterTail&gt; // 51</CODE>
<CODE>    // &lt;WriteParameterTail&gt; --&gt;  lambda RULE #52</CODE>
<CODE>    private void WriteParameterTail() {</CODE>
<CODE>        stackTrace += &quot;WriteParameterTail\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.WriteParameterTail)) {</CODE>
<CODE>            case 51: //rule 51</CODE>
<CODE>                match();</CODE>
<CODE>                WriteParameter();</CODE>
<CODE>                WriteParameterTail();</CODE>
<CODE>                break;</CODE>
<CODE>            case 52://case of e rule 52</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;,&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 30</CODE>
<CODE>    // &lt;WriteParameter&gt; --&gt; &lt;OrdinalExpression&gt; RULE #53</CODE>
<CODE>    private void WriteParameter() {</CODE>
<CODE>        stackTrace += &quot;WriteParameter\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.WriteParameter)) {</CODE>
<CODE>            case 53://rule 53</CODE>
<CODE>                Token t = l1;</CODE>
<CODE>                OrdinalExpression();</CODE>
<CODE>                sa.incWriteCount();</CODE>
<CODE>                //  sa.genWrite_S(); //  genWrite_S the terminal</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 31</CODE>
<CODE>    // &lt;AssignmentStatement&gt; --&gt; &lt;VariableIdentifier&gt; := &lt;Expression&gt; RULE #54</CODE>
<CODE>    // &lt;AssignmentStatement&gt; --&gt; &lt;FunctionIdentifier&gt; := &lt;Expression&gt; RULE #55</CODE>
<CODE>    private void AssignmentStatement() {</CODE>
<CODE>        stackTrace += &quot;AssignmentStatement\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.AssignmentStatement)) {</CODE>
<CODE>            case 54: //rule 54</CODE>
<CODE>                Token t = l1;</CODE>
<CODE>                VariableIdentifier();</CODE>
<CODE>                if (l1.getTerminal() == Terminal.ASSIGN) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    SemanticRecord returnstuff = Expression();</CODE>
<CODE>                    sa.genAssignment(new SemanticRecord(</CODE>
<CODE>                            t, sh.getEntry(t.getContents())), returnstuff);</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;assign&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            case 55://rule 55</CODE>
<CODE>                t = l1;</CODE>
<CODE>                FunctionIdentifier(); //rule 55</CODE>
<CODE>                if (l1.getTerminal() == Terminal.ASSIGN) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    SemanticRecord returnstuff = Expression();</CODE>
<CODE>                    sa.genAssignment(new SemanticRecord(</CODE>
<CODE>                            t, sh.getEntry(t.getContents())), returnstuff);</CODE>

<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;assign&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;else&quot;, &quot;e&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 32</CODE>
<CODE>//&lt;IfStatement&gt; -&gt; if &lt;BooleanExpression&gt; then &lt;Statement&gt;&lt;OptionalElsePart&gt;//45</CODE>
<CODE>    private void IfStatement() {</CODE>
<CODE>        stackTrace += &quot;IfStatement\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.IfStatement)) {</CODE>
<CODE>            case 56: //rule 56</CODE>
<CODE>                if (l1.getTerminal() == Terminal.IF) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    int toFalse = sa.newLabel(),</CODE>
<CODE>                            toEnd = sa.newLabel();</CODE>
<CODE>                    BooleanExpression();</CODE>
<CODE>                    sa.genBranchFalse_S(toFalse);</CODE>
<CODE>                    if (l1.getTerminal() == Terminal.THEN) {</CODE>
<CODE>                        match();</CODE>
<CODE>                        Statement();</CODE>
<CODE>                        sa.genBranch(toEnd);</CODE>
<CODE>                        sa.putLabel(toFalse);</CODE>
<CODE>                        OptionalElsePart();</CODE>
<CODE>                        sa.putLabel(toEnd);</CODE>
<CODE>                    } else {</CODE>
<CODE>                        String[] err = {&quot;then&quot;};</CODE>
<CODE>                        error(err);</CODE>
<CODE>                    }</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;if&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 33</CODE>
<CODE>    // &lt;OptionalElsePart&gt; --&gt; else &lt;Statement&gt; RULE #57</CODE>
<CODE>    // &lt;OptionalElsePart&gt; --&gt; lambda RULE #58</CODE>
<CODE>    private void OptionalElsePart() {</CODE>
<CODE>        stackTrace += &quot;OptionalElsePart\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.OptionalElsePart)) {</CODE>
<CODE>            case 57: //rule 57</CODE>
<CODE>                match();</CODE>
<CODE>                Statement();</CODE>
<CODE>                break;</CODE>
<CODE>            case 58://case of e rule 58</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;else&quot;, &quot;e&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>

<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 34</CODE>
<CODE>//&lt;RepeatStatement&gt; -&gt; repeat &lt;StatementSequence&gt; until &lt;BooleanExpression&gt; //59</CODE>
<CODE>    private void RepeatStatement() {</CODE>
<CODE>        stackTrace += &quot;RepeatStatement\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.RepeatStatement)) {</CODE>
<CODE>            case 59://rule 59</CODE>
<CODE>                if (l1.getTerminal() == Terminal.REPEAT) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    int top = sa.newLabel();</CODE>
<CODE>                    sa.putLabel(top);</CODE>
<CODE>                    StatementSequence();</CODE>
<CODE>                    if (l1.getTerminal() == Terminal.UNTIL) {</CODE>
<CODE>                        match();</CODE>
<CODE>                        BooleanExpression();</CODE>
<CODE>                        sa.genBranchFalse_S(top);</CODE>
<CODE>                    } else {</CODE>
<CODE>                        String[] err = {&quot;until&quot;};</CODE>
<CODE>                        error(err);</CODE>
<CODE>                    }</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;repeat&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 35</CODE>
<CODE>    // &lt;WhileStatement&gt; --&gt; while &lt;BooleanExpression&gt; do &lt;Statement&gt; RULE #60</CODE>
<CODE>    private void WhileStatement() {</CODE>
<CODE>        stackTrace += &quot;WhileStatment\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.WhileStatement)) {</CODE>
<CODE>            case 60://rule 60</CODE>
<CODE>                if (l1.getTerminal() == Terminal.WHILE) {</CODE>
<CODE>                    int loop = sa.newLabel(),</CODE>
<CODE>                            exit = sa.newLabel();</CODE>
<CODE>                    match();</CODE>
<CODE>                    sa.putLabel(loop);</CODE>
<CODE>                    BooleanExpression();</CODE>
<CODE>                    sa.genBranchFalse_S(exit);</CODE>
<CODE>                    if (l1.getTerminal() == Terminal.DO) {</CODE>
<CODE>                        match();</CODE>
<CODE>                        Statement();</CODE>
<CODE>                        sa.genBranch(loop);</CODE>
<CODE>                        sa.putLabel(exit);</CODE>
<CODE>                    } else {</CODE>
<CODE>                        String[] err = {&quot;do&quot;};</CODE>
<CODE>                        error(err);</CODE>
<CODE>                    }</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;while&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;while&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 36</CODE>
<CODE>    // &lt;ForStatement&gt; --&gt;</CODE>
<CODE>    //  for &lt;ControlVariable&gt; := &lt;InitialValue&gt; &lt;StepValue&gt; &lt;FinalValue&gt;</CODE>
<CODE>    //  do &lt;Statement&gt; RULE #61</CODE>
<CODE>    private void ForStatement() {</CODE>
<CODE>        stackTrace += &quot;ForStatement\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ForStatement)) {</CODE>
<CODE>            case 61://rule 61</CODE>
<CODE>                if (l1.getTerminal() == Terminal.FOR) {</CODE>
<CODE>                    match();</CODE>
<CODE>                    int loop = sa.newLabel(),</CODE>
<CODE>                            exit = sa.newLabel();</CODE>
<CODE>                    SemanticRecord control = ControlVariable();</CODE>
<CODE>                    if (l1.getTerminal() == Terminal.ASSIGN) {</CODE>
<CODE>                        match();</CODE>
<CODE>                        SemanticRecord initialvalue = InitialValue();</CODE>
<CODE>                        //  Either to or downto</CODE>
<CODE>                        boolean increment = StepValue();</CODE>
<CODE>                        SemanticRecord finalvalue = FinalValue();</CODE>
<CODE>                        sa.genForInitialize(control, initialvalue);</CODE>
<CODE>                        sa.putLabel(loop);</CODE>
<CODE>                        sa.genForTest(control, increment, finalvalue);</CODE>
<CODE>                        sa.genBranchFalse_S(exit);</CODE>
<CODE>                        if (l1.getTerminal() == Terminal.DO) {</CODE>
<CODE>                            match();</CODE>
<CODE>                            Statement();</CODE>
<CODE>                            sa.genForAlter(control, increment);</CODE>
<CODE>                            sa.genBranch(loop);</CODE>
<CODE>                            sa.putLabel(exit);</CODE>
<CODE>                        } else {</CODE>
<CODE>                            String[] err = {&quot;do&quot;};</CODE>
<CODE>                            error(err);</CODE>
<CODE>                        }</CODE>
<CODE>                    } else {</CODE>
<CODE>                        String[] err = {&quot;:=&quot;};</CODE>
<CODE>                        error(err);</CODE>
<CODE>                    }</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;for&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;for&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 37</CODE>
<CODE>    // &lt;ControlVariable&gt; --&gt; &lt;VariableIdentifier&gt; RULE #62</CODE>
<CODE>    private SemanticRecord ControlVariable() {</CODE>
<CODE>        stackTrace += &quot;ControlVariable\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ControlVariable)) {</CODE>
<CODE>            case 62://rule 62</CODE>
<CODE>                Token t = l1;</CODE>
<CODE>                VariableIdentifier();</CODE>
<CODE>                return new SemanticRecord(t, sh.getEntry(t.getContents()));</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 38</CODE>
<CODE>    // &lt;InitialValue&gt; --&gt; &lt;OrdinalExpression&gt; RULE #63</CODE>
<CODE>    private SemanticRecord InitialValue() {</CODE>
<CODE>        stackTrace += &quot;InitialValue\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.InitialValue)) {</CODE>
<CODE>            case 63://rule 63</CODE>
<CODE>                return OrdinalExpression();</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 39</CODE>
<CODE>    // &lt;StepValue&gt; --&gt; to RULE #64</CODE>
<CODE>    // &lt;StepValue&gt; --&gt; downto RULE #65</CODE>
<CODE>    private boolean StepValue() {</CODE>
<CODE>        stackTrace += &quot;StepValue\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.StepValue)) {</CODE>
<CODE>            case 64: //rule 64</CODE>
<CODE>                match();</CODE>
<CODE>                return true;</CODE>
<CODE>            case 65: //rule 65</CODE>
<CODE>                match();</CODE>
<CODE>                return false;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;to&quot;, &quot;downto&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                return true;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 40</CODE>
<CODE>    // &lt;FinalValue&gt; --&gt; &lt;OrdinalExpression&gt; RULE #66</CODE>
<CODE>    private SemanticRecord FinalValue() {</CODE>
<CODE>        stackTrace += &quot;FinalValue\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.FinalValue)) {</CODE>
<CODE>            case 66://rule 66</CODE>
<CODE>                return OrdinalExpression();</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 41</CODE>
<CODE>    // &lt;ProcedureStatement&gt; --&gt; &lt;ProcedureIdentifier&gt; &lt;OptionalActualParameterList&gt; RULE #67</CODE>
<CODE>    private void ProcedureStatement() {</CODE>
<CODE>        stackTrace += &quot;ProcedureStatment\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ProcedureStatement)) {</CODE>
<CODE>            case 67://rule 67</CODE>
<CODE>                String id = ProcedureIdentifier();</CODE>
<CODE>                Symbol procedure = sh.getEntry(id);</CODE>
<CODE>                ArrayList&lt;SemanticRecord&gt; params = OptionalActualParameterList();</CODE>
<CODE>                sa.onStartActualCall(procedure, params);</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 42</CODE>
<CODE>//&lt;OptionalActualParameterList&gt; -&gt; ( &lt;ActualParameter&gt;&lt;ActualParameterTail&gt;)//68</CODE>
<CODE>//&lt;OptionalActualParameterList&gt; -&gt; lambda RULE #69</CODE>
<CODE>    private ArrayList&lt;SemanticRecord&gt; OptionalActualParameterList() {</CODE>
<CODE>        stackTrace += &quot;OptionalActualParameterList\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.OptionalActualParameterList)) {</CODE>
<CODE>            case 68: //rule 68</CODE>
<CODE>                match();</CODE>
<CODE>                ArrayList&lt;SemanticRecord&gt; params = new ArrayList();</CODE>
<CODE>                params.add(ActualParameter());</CODE>
<CODE>                ActualParameterTail(params);</CODE>
<CODE>                if (l1.getTerminal() == Terminal.RPAREN) {</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;)&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                return params;</CODE>
<CODE>            case 69://rule 69 switch on e</CODE>
<CODE>                return new ArrayList();</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;(&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 43</CODE>
<CODE>    // &lt;ActualParameterTail&gt; --&gt; , &lt;ActualParameter&gt; &lt;ActualParameterTail&gt; // 70</CODE>
<CODE>    // &lt;ActualParameterTail&gt; --&gt; lambda RULE #71</CODE>
<CODE>    private void ActualParameterTail(ArrayList&lt;SemanticRecord&gt; params) {</CODE>
<CODE>        stackTrace += &quot;ActualParameterTail\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ActualParameterTail)) {</CODE>
<CODE>            case 70: //rule 70</CODE>
<CODE>                match();</CODE>
<CODE>                params.add(ActualParameter());</CODE>
<CODE>                ActualParameterTail(params);</CODE>
<CODE>                break;</CODE>
<CODE>            case 71: //e</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;,&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 44</CODE>
<CODE>    // &lt;ActualParameter&gt; --&gt; &lt;OrdinalExpression&gt; RULE #72</CODE>
<CODE>    private SemanticRecord ActualParameter() {</CODE>
<CODE>        stackTrace += &quot;ActualParameter\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ActualParameter)) {</CODE>
<CODE>            case 72:</CODE>
<CODE>                return OrdinalExpression();//rule 72</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 45</CODE>
<CODE>    // &lt;Expression&gt; --&gt; &lt;SimpleExpression&gt; &lt;OptionalRelationalPart&gt; RULE #73</CODE>
<CODE>    private SemanticRecord Expression() {</CODE>
<CODE>        stackTrace += &quot;Expression\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.Expression)) {</CODE>
<CODE>            case 73:</CODE>
<CODE>                SemanticRecord left = SimpleExpression();</CODE>
<CODE>                return OptionalRelationalPart(left);</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 46</CODE>
<CODE>    // &lt;OptionalRelationalPart&gt; --&gt; &lt;RelationalOperator&gt; &lt;SimpleExpression&gt; #74</CODE>
<CODE>    // &lt;OptionalRelationalPart&gt; --&gt; lambda RULE #75</CODE>
<CODE>    private SemanticRecord OptionalRelationalPart(SemanticRecord left) {</CODE>
<CODE>        stackTrace += &quot;OptionalRelationalPart\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.OptionalRelationalPart)) {</CODE>
<CODE>            case 74:</CODE>
<CODE>                Operator opp = RelationalOperator(); //rule 74</CODE>
<CODE>                SemanticRecord right = SimpleExpression(); //rule 74</CODE>
<CODE>                sa.genArithOperator_S(left, opp, right);</CODE>
<CODE>                return new SemanticRecord(</CODE>
<CODE>                        right.token, right.symbol, &quot;&quot;, &quot;&quot;, &quot;&quot;, Type.BOOLEAN);</CODE>
<CODE>            case 75://rule 75</CODE>
<CODE>                return left;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return left;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 47</CODE>
<CODE>    // RelationalOperator&gt; --&gt; = RULE #76</CODE>
<CODE>    // RelationalOperator&gt; --&gt; &lt; RULE #77</CODE>
<CODE>    // RelationalOperator&gt; --&gt; &gt; RULE #78</CODE>
<CODE>    // RelationalOperator&gt; --&gt; &lt;= RULE #79</CODE>
<CODE>    // RelationalOperator&gt; --&gt; &gt;= RULE #80</CODE>
<CODE>    // RelationalOperator&gt; --&gt; &lt;&gt; RULE #81</CODE>
<CODE>    private Operator RelationalOperator() {</CODE>
<CODE>        stackTrace += &quot;RelationalOperator\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.RelationalOperator)) {</CODE>
<CODE>            case 76: //rule 76</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.EQUAL;</CODE>
<CODE>            case 77: //rule 77</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.LTHAN;</CODE>
<CODE>            case 78: //rule 78</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.GTHAN;</CODE>
<CODE>            case 79: //rule 79</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.LEQUAL;</CODE>
<CODE>            case 80: //rule 80</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.GEQUAL;</CODE>
<CODE>            case 81: //rule 81</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.NEQUAL;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;EQUAL&quot;, &quot;LTHAN&quot;, &quot;GTHAN&quot;, &quot;LEQUAL&quot;, &quot;GEQUAL&quot;,</CODE>
<CODE>                    &quot;NEQUAL&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return Operator.NOOP;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    //**************************************************************************</CODE>
<CODE>    //stubs for rules 78 - 150</CODE>
<CODE>    // Nonterminal 48</CODE>
<CODE>    // &lt;SimpleExpression&gt; --&gt; &lt;OptionalSign&gt; &lt;Term&gt; &lt;TermTail&gt; RULE #82</CODE>
<CODE>    private SemanticRecord SimpleExpression() {</CODE>
<CODE>        stackTrace += &quot;SimpleExpression\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.SimpleExpression)) {</CODE>
<CODE>            case 82:</CODE>
<CODE>                boolean positive = OptionalSign(); // Rule 82</CODE>
<CODE>                SemanticRecord left = Term();</CODE>
<CODE>                if (!positive) {</CODE>
<CODE>                    sa.genNegation_S(left);</CODE>
<CODE>                }</CODE>
<CODE>                return TermTail(left);</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 49</CODE>
<CODE>    // &lt;TermTail&gt; --&gt; &lt;AddingOperator&gt; &lt;Term&gt; &lt;TermTail&gt; RULE #83</CODE>
<CODE>    // &lt;TermTail&gt; --&gt; lambda RULE #84</CODE>
<CODE>    private SemanticRecord TermTail(SemanticRecord left) {</CODE>
<CODE>        stackTrace += &quot;TermTail\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.TermTail)) {</CODE>
<CODE>            case 83:</CODE>
<CODE>                Operator opp = AddingOperator();</CODE>
<CODE>                SemanticRecord right = Term();</CODE>
<CODE>                SemanticRecord sum;</CODE>
<CODE>                if (opp == Operator.OR) {</CODE>
<CODE>                    sa.genLogicalOperator_S(left, opp, right);</CODE>
<CODE>                    sum = left;</CODE>
<CODE>                } else {</CODE>
<CODE>                    boolean floating = sa.genArithOperator_S(left, opp, right);</CODE>
<CODE>                    sum = new SemanticRecord(right.token, null, &quot;&quot;, &quot;&quot;, &quot;&quot;,</CODE>
<CODE>                            floating ? Type.FLOAT : Type.INTEGER);</CODE>
<CODE>                }</CODE>

<CODE>                // have enough information for creating arithmitic operation </CODE>
<CODE>                return TermTail(sum);</CODE>
<CODE>            case 84:</CODE>
<CODE>                return left;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return left;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 50</CODE>
<CODE>    // &lt;OptionalSign&gt; --&gt; + RULE #86</CODE>
<CODE>    // &lt;OptionalSign&gt; --&gt; - RULE #87</CODE>
<CODE>    // &lt;OptionalSign&gt; --&gt; lambda RULE #88</CODE>
<CODE>    private boolean OptionalSign() {</CODE>
<CODE>        stackTrace += &quot;OptionalSign\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.OptionalSign)) {</CODE>
<CODE>            case 85: // +</CODE>
<CODE>                match();</CODE>
<CODE>                return true;</CODE>
<CODE>            case 86: // -</CODE>
<CODE>                match();</CODE>
<CODE>                return false;</CODE>
<CODE>            case 87: // e</CODE>
<CODE>                return true;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;+&quot;, &quot;-&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return true;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 51</CODE>
<CODE>    // &lt;AddingOperator&gt; --&gt; + RULE #89</CODE>
<CODE>    // &lt;AddingOperator&gt; --&gt; - RULE #90</CODE>
<CODE>    // &lt;AddingOperator&gt; --&gt; or RULE #91</CODE>
<CODE>    private Operator AddingOperator() {</CODE>
<CODE>        stackTrace += &quot;AddingOperator\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.AddingOperator)) {</CODE>
<CODE>            case 88: // +</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.ADDITION;</CODE>
<CODE>            case 89: // -</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.SUBTRACTION;</CODE>
<CODE>            case 90: // or</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.OR;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;+&quot;, &quot;-&quot;, &quot;or&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return Operator.NOOP;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 52</CODE>
<CODE>    // &lt;Term&gt; --&gt; &lt;Factor&gt; &lt;FactorTail&gt; RULE #91</CODE>
<CODE>    private SemanticRecord Term() {</CODE>
<CODE>        stackTrace += &quot;Term\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.Term)) {</CODE>
<CODE>            case 91:</CODE>
<CODE>                SemanticRecord left = Factor();      // RULE 91</CODE>
<CODE>                return FactorTail(left);  // RULE 91</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 53</CODE>
<CODE>    // &lt;FactorTail&gt; --&gt; &lt;MultiplyingOperator&gt; &lt;Factor&gt; &lt;FactorTail&gt; RULE #92</CODE>
<CODE>    // &lt;FactorTail&gt; --&gt; lambda RULE #93</CODE>
<CODE>    private SemanticRecord FactorTail(SemanticRecord left) {</CODE>
<CODE>        stackTrace += &quot;FactorTail\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.FactorTail)) {</CODE>
<CODE>            case 92:</CODE>
<CODE>                Operator opp = MultiplyingOperator();</CODE>
<CODE>                SemanticRecord right = Factor();</CODE>
<CODE>                SemanticRecord product;</CODE>
<CODE>                if (opp == Operator.AND) {</CODE>
<CODE>                    sa.genLogicalOperator_S(left, opp, right);</CODE>
<CODE>                    product = right;</CODE>
<CODE>                } else {</CODE>
<CODE>                    boolean floating = sa.genArithOperator_S(left, opp, right);</CODE>
<CODE>                    product = new SemanticRecord(</CODE>
<CODE>                            right.token, right.symbol, &quot;&quot;, &quot;&quot;, &quot;&quot;,</CODE>
<CODE>                            //  Need to handle whether it was casted</CODE>
<CODE>                            floating ? Type.FLOAT : Type.INTEGER);</CODE>
<CODE>                }</CODE>
<CODE>                return FactorTail(product);</CODE>
<CODE>            case 93:</CODE>
<CODE>                return left;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;operator&quot;, &quot;end of expression&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return left;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 54</CODE>
<CODE>    // &lt;MultiplyingOperator&gt; --&gt; * RULE #94</CODE>
<CODE>    // &lt;MultiplyingOperator&gt; --&gt; / RULE #95</CODE>
<CODE>    // &lt;MultiplyingOperator&gt; --&gt; div RULE #96</CODE>
<CODE>    // &lt;MultiplyingOperator&gt; --&gt; mod RULE #97</CODE>
<CODE>    // &lt;MultiplyingOperator&gt; --&gt; and RULE #98</CODE>
<CODE>    private Operator MultiplyingOperator() {</CODE>
<CODE>        stackTrace += &quot;MultiplyingOperator\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.MultiplyingOperator)) {</CODE>
<CODE>            case 94:         //  * RULE 94</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.MULTIPLICATION;</CODE>
<CODE>            case 95:  // / RULE 95</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.FLOAT_DIVISION;</CODE>
<CODE>            case 96:           // / RULE 96</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.DIVISION;</CODE>
<CODE>            case 97:           // % RULE 97</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.MODULO;</CODE>
<CODE>            case 98:           // and RULE 98</CODE>
<CODE>                match();</CODE>
<CODE>                return Operator.AND;</CODE>
<CODE>            default:</CODE>
<CODE>                String exp[] = {&quot;*&quot;, &quot;/&quot;, &quot;div&quot;, &quot;%&quot;, &quot;and&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return Operator.NOOP;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 55</CODE>
<CODE>    // &lt;Factor&gt; --&gt; unsignedInteger RULE #99</CODE>
<CODE>    // &lt;Factor&gt; --&gt; unsignedFloat RULE #100</CODE>
<CODE>    // &lt;Factor&gt; --&gt; stringLiteral RULE #101</CODE>
<CODE>    // &lt;Factor&gt; --&gt; TRUE RULE #102</CODE>
<CODE>    // &lt;Factor&gt; --&gt; FALSE RULE #103</CODE>
<CODE>    // &lt;Factor&gt; --&gt; not &lt;Factor&gt; RULE #104</CODE>
<CODE>    // &lt;Factor&gt; --&gt; ( &lt;Expression&gt; ) RULE #105</CODE>
<CODE>    // &lt;Factor&gt; --&gt; &lt;FunctionIdentifier&gt; &lt;OptionalActualParamterList&gt; RULE #106</CODE>
<CODE>    // &lt;Factor&gt; --&gt; &lt;VariableIdentifier&gt; RULE #116</CODE>
<CODE>    private SemanticRecord Factor() {</CODE>
<CODE>        stackTrace += &quot;Factor\n&quot;;</CODE>

<CODE>        //handle special case in table that branchs when id is not at end of</CODE>
<CODE>        //statement</CODE>
<CODE>        int rule = getRule(NonTerminal.Factor);</CODE>
<CODE>        if (rule == 106) {</CODE>
<CODE>            l2 = scanner.nextToken();</CODE>
<CODE>            if (l2.getTerminal() != Terminal.LPAREN) {</CODE>
<CODE>                rule = 116;</CODE>
<CODE>            }</CODE>
<CODE>        }</CODE>
<CODE>        SemanticRecord r;</CODE>
<CODE>        switch (rule) {</CODE>
<CODE>            case 99:</CODE>
<CODE>                r = new SemanticRecord(l1, null);</CODE>
<CODE>                sa.genPush(r);</CODE>
<CODE>                match();</CODE>
<CODE>                return r;</CODE>
<CODE>            case 100:</CODE>
<CODE>                r = new SemanticRecord(l1, null);</CODE>
<CODE>                sa.genPush(r);</CODE>
<CODE>                match();</CODE>
<CODE>                return r;</CODE>
<CODE>            case 101:</CODE>
<CODE>                r = new SemanticRecord(l1, null);</CODE>
<CODE>                sa.genPush(r);</CODE>
<CODE>                match();</CODE>
<CODE>                return r;</CODE>
<CODE>            case 102:          // RULE 102 True</CODE>
<CODE>                r = new SemanticRecord(l1, null);</CODE>
<CODE>                sa.genPush(r);</CODE>
<CODE>                match();</CODE>
<CODE>                return r;</CODE>
<CODE>            case 103:         // RULE 103 False</CODE>
<CODE>                r = new SemanticRecord(l1, null);</CODE>
<CODE>                sa.genPush(r);</CODE>
<CODE>                match();</CODE>
<CODE>                return r;</CODE>
<CODE>            case 104:           // not Factor() RULE 104</CODE>
<CODE>                match();</CODE>
<CODE>                r = Factor();</CODE>
<CODE>                sa.genNot_S();</CODE>
<CODE>                return r;</CODE>
<CODE>            case 105:        // RULE 105</CODE>
<CODE>                match();</CODE>
<CODE>                r = Expression();</CODE>
<CODE>                switch (l1.getTerminal()) {</CODE>
<CODE>                    case RPAREN:</CODE>
<CODE>                        match();</CODE>
<CODE>                        break;</CODE>
<CODE>                    default:</CODE>
<CODE>                        String exp[] = {&quot;)&quot;};</CODE>
<CODE>                        error(exp);</CODE>
<CODE>                }</CODE>
<CODE>                return r;</CODE>
<CODE>            case 106:   // RULE 106</CODE>
<CODE>                Symbol entry = sh.getEntry(l1.getContents());</CODE>
<CODE>                if (entry.kind == Kind.PROCEDURE) {</CODE>
<CODE>                    sa.error(&quot;Procedures have no type. &quot;</CODE>
<CODE>                            + l1.getContents() + &quot; at line &quot; + l1.getLine() + &quot; col &quot;</CODE>
<CODE>                            + l1.getCol());</CODE>
<CODE>                    return new SemanticRecord(l1, sh.getEntry(l1.getContents()));</CODE>
<CODE>                }</CODE>
<CODE>                if (entry.kind == Kind.FUNCTION) {</CODE>
<CODE>                    r = new SemanticRecord(l1, entry);</CODE>
<CODE>                    Symbol function = sh.getEntry(FunctionIdentifier());</CODE>
<CODE>                    ArrayList&lt;SemanticRecord&gt; params</CODE>
<CODE>                            = OptionalActualParameterList();</CODE>
<CODE>                    sa.onStartActualCall(function, params);</CODE>
<CODE>                    return r;</CODE>
<CODE>                }</CODE>
<CODE>            //  Fall through. It wasn't a function, so it should be identifier.</CODE>
<CODE>            case 116:  // RULE 116</CODE>
<CODE>                r = new SemanticRecord(l1, sh.getEntry(l1.getContents()));</CODE>
<CODE>                sa.genPush(r);</CODE>
<CODE>                match();</CODE>
<CODE>                return r;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] exp = {&quot;INTEGER&quot;, &quot;FLOAT&quot;, &quot;STRING_LIT&quot;, &quot;TRUE&quot;,</CODE>
<CODE>                    &quot;FALSE&quot;, &quot;NOT&quot;, &quot;LPAREN EXPRESSION RPAREN&quot;,</CODE>
<CODE>                    &quot;FunctionIdentifier OptionalActualParameterList&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 56</CODE>
<CODE>    // &lt;ProgramIdentifier&gt; --&gt; identifier RULE #107</CODE>
<CODE>    private void ProgramIdentifier() {</CODE>
<CODE>        stackTrace += &quot;ProgramIdentifier\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ProgramIdentifier)) {</CODE>
<CODE>            case 107:    // RULE 107</CODE>
<CODE>                match();</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] exp = {&quot;IDENTIFIER&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 57</CODE>
<CODE>    // &lt;VariableIdentifier&gt; --&gt; identifier RULE #108</CODE>
<CODE>    private String VariableIdentifier() {</CODE>
<CODE>        stackTrace += &quot;VariableIdentifier\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.VariableIdentifier)) {</CODE>
<CODE>            case 108:    // RULE 108</CODE>
<CODE>                String str = l1.getContents();</CODE>
<CODE>                match();</CODE>
<CODE>                return str;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] exp = {&quot;IDENTIFIER&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return &quot;&quot;;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 58</CODE>
<CODE>    // &lt;ProcedureIdentifier&gt; --&gt; identifier RULE #109</CODE>
<CODE>    private String ProcedureIdentifier() {</CODE>
<CODE>        stackTrace += &quot;ProcedureIdentifier\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.ProcedureIdentifier)) {</CODE>
<CODE>            case 109:     // RULE 109</CODE>
<CODE>                String str = l1.getContents();</CODE>
<CODE>                match();</CODE>
<CODE>                return str;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] exp = {&quot;IDENTIFIER&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return &quot;&quot;;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 59</CODE>
<CODE>    // &lt;FunctionIdentifier&gt; --&gt; identifier RULE #111</CODE>
<CODE>    private String FunctionIdentifier() {</CODE>
<CODE>        stackTrace += &quot;FunctionIdentifier\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.FunctionIdentifier)) {</CODE>
<CODE>            case 110:    // RULE 110</CODE>
<CODE>                String str = l1.getContents();</CODE>
<CODE>                match();</CODE>
<CODE>                return str;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] exp = {&quot;IDENTIFIER&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return &quot;&quot;;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 60</CODE>
<CODE>    // &lt;BooleanExpression&gt; --&gt; &lt;Expression&gt; RULE #112</CODE>
<CODE>    private void BooleanExpression() {</CODE>
<CODE>        stackTrace += &quot;BooleanExpression\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.BooleanExpression)) {</CODE>
<CODE>            case 111:    // RULE 111</CODE>
<CODE>                Expression();           // RULE 111</CODE>
<CODE>                break;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] exp = {&quot;&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                break;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 61</CODE>
<CODE>    // &lt;OrdinalExpression&gt; --&gt; &lt;Expression&gt; RULE #113</CODE>
<CODE>    private SemanticRecord OrdinalExpression() {</CODE>
<CODE>        stackTrace += &quot;OrdinalExpression\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.OrdinalExpression)) {</CODE>
<CODE>            case 112:    // RULE 112</CODE>
<CODE>                return Expression();</CODE>
<CODE>            default:</CODE>
<CODE>                String[] exp = {&quot;expression&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 62</CODE>
<CODE>    // &lt;IdentifierList&gt; --&gt; identifier &lt;IdentifierTail&gt; RULE #114</CODE>
<CODE>    private ArrayList&lt;String&gt; IdentifierList() {</CODE>
<CODE>        stackTrace += &quot;IdentifierList\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.IdentifierList)) {</CODE>
<CODE>            case 113:    // RULE 113</CODE>
<CODE>                ArrayList&lt;String&gt; str = new ArrayList();</CODE>
<CODE>                str.add(l1.getContents());</CODE>
<CODE>                match();</CODE>
<CODE>                return IdentifierTail(str);</CODE>
<CODE>            default:</CODE>
<CODE>                String[] exp = {&quot;IDENTIFIER&quot;};</CODE>
<CODE>                error(exp);</CODE>
<CODE>                return null;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    // Nonterminal 63</CODE>
<CODE>    // &lt;IdentifierTail&gt; --&gt; , identifier &lt;IdentifierTail&gt; RULE #115</CODE>
<CODE>    // &lt;IdentifierTail&gt; --&gt; lambda</CODE>
<CODE>    private ArrayList&lt;String&gt; IdentifierTail(ArrayList&lt;String&gt; str) {</CODE>
<CODE>        stackTrace += &quot;IdentifierTail\n&quot;;</CODE>
<CODE>        switch (getRule(NonTerminal.IdentifierTail)) {</CODE>
<CODE>            case 114:</CODE>
<CODE>                match(); // RULE 114</CODE>
<CODE>                if (l1.getTerminal() == Terminal.IDENTIFIER) {</CODE>
<CODE>                    str.add(l1.getContents());</CODE>
<CODE>                    match();</CODE>
<CODE>                } else {</CODE>
<CODE>                    String[] err = {&quot;IDENTIFIER&quot;};</CODE>
<CODE>                    error(err);</CODE>
<CODE>                }</CODE>
<CODE>                return IdentifierTail(str);</CODE>
<CODE>            case 115: // for rule 115</CODE>
<CODE>                return str;</CODE>
<CODE>            default:</CODE>
<CODE>                String[] err = {&quot;COMMA IDENTIFIER IdentifierTail&quot;};</CODE>
<CODE>                error(err);</CODE>
<CODE>                return str;</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    /**</CODE>
<CODE>     * genRead in csv ll1 table</CODE>
<CODE>     *</CODE>
<CODE>     * @param sa semantic analyzer object</CODE>
<CODE>     */</CODE>
<CODE>    public Parser(SemanticAnalyzer sa) {</CODE>
<CODE>        this.sa = sa;</CODE>
<CODE>        this.sh = sa.sh;</CODE>
<CODE>    }</CODE>

<CODE>    /**</CODE>
<CODE>     * Set a file to parse</CODE>
<CODE>     *</CODE>
<CODE>     * @param in file to be parsed</CODE>
<CODE>     * @return 0 on success</CODE>
<CODE>     */</CODE>
<CODE>    public boolean parseFile(String in) {</CODE>
<CODE>        scanner = new Scanner(in);</CODE>
<CODE>        l1 = scanner.nextToken();</CODE>
<CODE>        SystemGoal();</CODE>
<CODE>        if (Compiler.DEBUG) {</CODE>
<CODE>            rFile.close();</CODE>
<CODE>        }</CODE>
<CODE>        scanner.close();</CODE>
<CODE>        return noerrors;</CODE>
<CODE>    }</CODE>

<CODE>    // Prints the rule taken</CODE>
<CODE>    private int ruleFile(int rule) {</CODE>
<CODE>        if (Compiler.DEBUG) {</CODE>
<CODE>            if (rFile == null) {</CODE>
<CODE>                try {</CODE>
<CODE>                    rFile = new PrintWriter(rule_tree_file);</CODE>
<CODE>                    rFile.println(&quot;Rules Taken,Token,Non-Terminal&quot;);</CODE>
<CODE>                } catch (Exception e) {</CODE>
<CODE>                    System.out.println(&quot;Unable to make file &quot; + rule_tree_file);</CODE>
<CODE>                    return 1;</CODE>
<CODE>                }</CODE>
<CODE>            }</CODE>
<CODE>            rFile.print(rule + &quot;,&quot; + l1);</CODE>
<CODE>        }</CODE>
<CODE>        return 0;</CODE>
<CODE>    }</CODE>

<CODE>    /**</CODE>
<CODE>     * Used to set the output file for the rule tree created when parsing</CODE>
<CODE>     *</CODE>
<CODE>     * @param in name of file or directory</CODE>
<CODE>     */</CODE>
<CODE>    public void setRuleOutputFile(String in) {</CODE>
<CODE>        this.rule_tree_file = in;</CODE>
<CODE>    }</CODE>

<CODE>    /**</CODE>
<CODE>     * If match was found consume it and look ahead</CODE>
<CODE>     */</CODE>
<CODE>    private void match() {</CODE>
<CODE>        if (l1 == null) {</CODE>
<CODE>            System.err.println(&quot;Invalid input to parser match function.&quot;);</CODE>
<CODE>            System.exit(1);</CODE>
<CODE>        }</CODE>
<CODE>        if (l2 == null) {</CODE>
<CODE>            l1 = scanner.nextToken();</CODE>
<CODE>        } else {</CODE>
<CODE>            l1 = l2;</CODE>
<CODE>            l2 = null;</CODE>
<CODE>        }</CODE>
<CODE>        if (l1 == null) {</CODE>
<CODE>            System.err.println(&quot;Scanner gave the parser a null token&quot;);</CODE>
<CODE>            System.exit(1);</CODE>
<CODE>        }</CODE>
<CODE>    }</CODE>

<CODE>    /**</CODE>
<CODE>     * handle error print out</CODE>
<CODE>     *</CODE>
<CODE>     * @param err token that caused the error</CODE>
<CODE>     * @param expected array of expected tokens</CODE>
<CODE>     */</CODE>
<CODE>    private void error(String[] expected) {</CODE>
<CODE>        if (expected == null) {</CODE>
<CODE>            System.err.println(&quot;Improper input to parser error function.&quot;);</CODE>
<CODE>        }</CODE>
<CODE>        noerrors = false;</CODE>
<CODE>        System.err.println(&quot;Parse Error: found &quot; + l1.getContents() + &quot; &quot;</CODE>
<CODE>                + l1.getTerminal() + &quot; at line &quot; + l1.getLine() + &quot; col &quot;</CODE>
<CODE>                + l1.getCol());</CODE>
<CODE>        System.err.print(&quot;Was expecting &quot;);</CODE>
<CODE>        System.err.print(Arrays.toString(expected));</CODE>
<CODE>        System.err.println(&quot;&quot;);</CODE>

<CODE>        /* possibly a system exit here? */</CODE>
<CODE>        if (Compiler.DEBUG) {</CODE>
<CODE>            System.out.println(stackTrace);</CODE>
<CODE>        }</CODE>
<CODE>        rFile.close();</CODE>
<CODE>        System.exit(0);</CODE>
<CODE>    }</CODE>

<CODE>    /**</CODE>
<CODE>     * Get the rule to execute</CODE>
<CODE>     *</CODE>
<CODE>     * @param rule The current rule</CODE>
<CODE>     * @return The rule to execute</CODE>
<CODE>     */</CODE>
<CODE>    private int getRule(NonTerminal nt) {</CODE>
<CODE>        //  The index corresponding to the current look ahead token</CODE>
<CODE>        int index = l1.getTerminal().ordinal(),</CODE>
<CODE>                nonTerminal = nt.ordinal();</CODE>

<CODE>        if (nonTerminal &gt; Table.length) {</CODE>
<CODE>            System.out.println(&quot;Error nonTerminal &quot; + nonTerminal</CODE>
<CODE>                    + &quot; is not in table&quot;);</CODE>
<CODE>            System.exit(1);</CODE>
<CODE>        }</CODE>
<CODE>        if (index &gt; Table[nonTerminal].length) {</CODE>
<CODE>            System.out.println(&quot;Error token &quot; + index + &quot;  &quot; + l1.getTerminal()</CODE>
<CODE>                    + &quot; not in table &quot;);</CODE>
<CODE>            System.out.println(&quot; &quot; + Table[nonTerminal].length);</CODE>
<CODE>            System.exit(1);</CODE>
<CODE>        }</CODE>

<CODE>        // integer corresponding to rule taken</CODE>
<CODE>        int rule = Table[nonTerminal][index];</CODE>
<CODE>        if (Compiler.DEBUG) {</CODE>
<CODE>            ruleFile(rule); // genWrite_S the rule taken</CODE>
<CODE>            rFile.print(&quot;,&quot; + nt + &quot;\n&quot;); //print terminal taken</CODE>
<CODE>        }</CODE>
<CODE>        return rule;</CODE>
<CODE>    }</CODE>

<CODE>    private final SymbolTableHandler sh;</CODE>
<CODE>    private final SemanticAnalyzer sa;</CODE>
<CODE>    private Token l1; // look ahead token</CODE>
<CODE>    private Token l2; // used for some cases when table is ll2</CODE>
<CODE>    private Scanner scanner;</CODE>
<CODE>    private PrintWriter rFile;</CODE>
<CODE>    //  Contains rules for going from non-terminals to terminals</CODE>
<CODE>    //  Helpful for debugging</CODE>
<CODE>    private String rule_tree_file = &quot;rule_list.csv&quot;;</CODE>
<CODE>    private boolean noerrors = true;</CODE>
<CODE>    private String stackTrace = &quot;&quot;;</CODE>

<CODE>    //  The best design choice you've ever seen</CODE>
<CODE>    private final int Table[][] = {</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, 13, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, 22, 21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, 31, -1, -1, -1, -1, -1, 31, -1, -1, -1, 31, -1, 31, -1, -1, -1, -1, -1, -1, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 31, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, 35, -1, -1, -1, -1, 34, 34, -1, -1, -1, 42, -1, 39, -1, -1, -1, -1, 43, -1, 36, 41, -1, -1, -1, -1, 34, -1, 40, 37, 37, 38, -1, -1, -1, -1, -1, 34, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, 44, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 45, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 51, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, 53, 53, 53, 53, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1, 53, 53, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, 57, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 63, -1, -1, -1, -1, -1, -1, -1, 63, -1, -1, -1, -1, -1, -1, -1, -1, 63, -1, -1, -1, -1, -1, 63, 63, 63, 63, -1, -1, -1, -1, 63, -1, -1, -1, -1, -1, -1, -1, -1, 63, 63, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, 66, 66, 66, 66, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, -1, -1, -1, 66, 66, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 67, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, 69, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, 68, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 70, -1, -1, -1, 71, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, 72, 72, 72, 72, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, -1, -1, 72, 72, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, 73, 73, 73, 73, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, -1, 73, 73, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, 75, 75, 75, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 75, -1, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 75, -1, 75, 75, 74, 74, 74, 74, 74, 74, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, 78, 77, 79, 80, 81, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, 82, 82, 82, 82, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, -1, 82, 82, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, 84, 84, 84, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, 83, -1, -1, -1, -1, -1, 84, 84, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, 84, -1, -1, 84, 84, 84, 84, 84, 84, 84, -1, 83, 83, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, 87, 87, 87, 87, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, -1, -1, -1, 85, 86, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 89, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, 91, 91, 91, 91, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {92, -1, -1, 92, 93, 93, 93, 93, -1, -1, -1, -1, -1, -1, -1, 92, -1, 93, -1, -1, -1, -1, -1, 93, 93, -1, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, 93, 93, -1, -1, 93, 93, 93, 93, 93, 93, 93, -1, 93, 93, 92, 92},</CODE>
<CODE>        {98, -1, -1, 96, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, 95},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 103, -1, -1, -1, -1, -1, -1, -1, 104, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, -1, -1, -1, -1, 106, 99, 100, 101, -1, -1, -1, -1, 105, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 107, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 109, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 110, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 111, -1, -1, -1, -1, -1, -1, -1, 111, -1, -1, -1, -1, -1, -1, -1, -1, 111, -1, -1, -1, -1, -1, 111, 111, 111, 111, -1, -1, -1, -1, 111, -1, -1, -1, -1, -1, -1, -1, -1, 111, 111, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, 112, -1, -1, -1, -1, -1, -1, -1, 112, -1, -1, -1, -1, -1, -1, -1, -1, 112, -1, -1, -1, -1, -1, 112, 112, 112, 112, -1, -1, -1, -1, 112, -1, -1, -1, -1, -1, -1, -1, -1, 112, 112, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 113, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, 115, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}</CODE>
<CODE>    };</CODE>
<CODE>    /*  Hard-to-read one that doesn't text-wrap in the document</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 4, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, 6, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 8, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, 13, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, 10, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, 14, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, 22, </CODE>
<CODE>     21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, -1, </CODE>
<CODE>     -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, 25, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, 31, -1, -1, -1, -1, -1, 31, -1, -1, -1, 31, -1, 31, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 31, -1, -1, -1, -1, -1, 31, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 32, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, 35, -1, -1, -1, -1, 34, 34, -1, -1, -1, 42, -1, 39, -1, -1, -1, -1, 43, -</CODE>
<CODE>     1, 36, 41, -1, -1, -1, -1, 34, -1, 40, 37, 37, 38, -1, -1, -1, -1, -1, 34, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, 44, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 44, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, 45, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, -1, </CODE>
<CODE>     -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, 50, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 51, -1, -1, </CODE>
<CODE>     -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, 53, 53, 53, 53, -1, -1, -1, -1, </CODE>
<CODE>     53, -1, -1, -1, -1, -1, -1, -1, -1, 53, 53, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, 57, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, 59, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, 60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 63, -1, -1, -1, -1, -1, -1, -1, 63, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, 63, -1, -1, -1, -1, -1, 63, 63, 63, 63, -1, -1, -1, -1, </CODE>
<CODE>     63, -1, -1, -1, -1, -1, -1, -1, -1, 63, 63, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, 66, 66, 66, 66, -1, -1, -1, -1, </CODE>
<CODE>     66, -1, -1, -1, -1, -1, -1, -1, -1, 66, 66, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 67, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, 69, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, </CODE>
<CODE>     68, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 70, -1, -1, </CODE>
<CODE>     -1, 71, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, -1, 72, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, 72, 72, 72, 72, -1, -1, -1, -1, </CODE>
<CODE>     72, -1, -1, -1, -1, -1, -1, -1, -1, 72, 72, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, 73, 73, 73, 73, -1, -1, -1, -1, </CODE>
<CODE>     73, -1, -1, -1, -1, -1, -1, -1, -1, 73, 73, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, 75, 75, 75, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, 75, 75, -1, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 75, -1, </CODE>
<CODE>     75, 75, 74, 74, 74, 74, 74, 74, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, 76, 78, 77, 79, 80, 81, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, 82, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, 82, 82, 82, 82, -1, -1, -1, -1, </CODE>
<CODE>     82, -1, -1, -1, -1, -1, -1, -1, -1, 82, 82, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, 84, 84, 84, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, 83, -1, -</CODE>
<CODE>     1, -1, -1, -1, 84, 84, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, 84, -1, </CODE>
<CODE>     -1, 84, 84, 84, 84, 84, 84, 84, -1, 83, 83, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, -1, -1, 87, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, 87, 87, 87, 87, -1, -1, -1, -1, </CODE>
<CODE>     87, -1, -1, -1, -1, -1, -1, -1, -1, 85, 86, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 90, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 89, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, 91, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, 91, 91, 91, 91, -1, -1, -1, -1, </CODE>
<CODE>     91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {92, -1, -1, 92, 93, 93, 93, 93, -1, -1, -1, -1, -1, -1, -1, 92, -1, 93, -1, -</CODE>
<CODE>     1, -1, -1, -1, 93, 93, -1, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, 93, 93, -1, </CODE>
<CODE>     -1, 93, 93, 93, 93, 93, 93, 93, -1, 93, 93, 92, 92},</CODE>
<CODE>     {98, -1, -1, 96, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, 95},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 103, -1, -1, -1, -1, -1, -1, -1, 104, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, 102, -1, -1, -1, -1, -1, 106, 99, 100, 101, -1, -1, -</CODE>
<CODE>     1, -1, 105, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 107, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 109, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 110, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 111, -1, -1, -1, -1, -1, -1, -1, 111, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, 111, -1, -1, -1, -1, -1, 111, 111, 111, 111, -1, -1, -</CODE>
<CODE>     1, -1, 111, -1, -1, -1, -1, -1, -1, -1, -1, 111, 111, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, 112, -1, -1, -1, -1, -1, -1, -1, 112, -1, -1, </CODE>
<CODE>     -1, -1, -1, -1, -1, -1, 112, -1, -1, -1, -1, -1, 112, 112, 112, 112, -1, -1, -</CODE>
<CODE>     1, -1, 112, -1, -1, -1, -1, -1, -1, -1, -1, 112, 112, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 113, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},</CODE>
<CODE>     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -</CODE>
<CODE>     1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, </CODE>
<CODE>     115, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}</CODE>
<CODE>     */</CODE>
<CODE>}</CODE>
<!-- InstanceEndEditable --></PRE>
</DIV>
<P><!-- InstanceEnd --></P>
</BODY>
</HTML>